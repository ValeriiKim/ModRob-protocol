#include "stdio.h"
// Библиотеки микроконтроллера
// #include "stm32f1xx_hal.h"
#include "stm32f1xx.h"

// Библиотеки CanFestival
#include "canfestival.h"
#include "can_stm32.h"
#include "TestMaster.h"

// Различные вспомогательные библиотеки
#include "lwrb.h"
extern "C"
{
	#include "ringbuffer.h"
}

#define ARRAY_LEN(x)  (sizeof(x) / sizeof((x)[0])) // определение числа элементов массива

#define SYSCLOCK 72000000U // максимальная частота контроллера

#define GREEN_LED_ON    SET_BIT(GPIOC->BSRR, GPIO_BSRR_BR13);
#define GREEN_LED_OFF   SET_BIT(GPIOC->BSRR, GPIO_BSRR_BS13);
#define TESTPIN_ON      SET_BIT(GPIOA->BSRR, GPIO_BSRR_BR9);
#define TESTPIN_OFF     SET_BIT(GPIOA->BSRR, GPIO_BSRR_BS9);

// Глобальные переменные
volatile uint32_t tmpreg;
volatile uint32_t SysTick_CNT = 0;

// Переменные для работы с буфером UART (DMA TX и приём RX)
// Набор переменных для буфера передачи TX
static lwrb_t usart_dma_tx_buff;
static uint8_t usart_dma_tx_buff_data[256];
static size_t usart_dma_tx_len;
// Набор переменных для буфера приёма RX
static uint8_t usart_rx_rawbuf[128];
static lwrb_t usart_rx_ringbuf;
static uint8_t usart_rx_ringbuf_data[128];

/* Сброс настроек тактового генератора */
void clock_deinit()
{
	// Включаем в начале HSI (внутренний генератор 8 МГц)
	SET_BIT(RCC->CR, RCC_CR_HSION);
	// ждём пока не стабилизируется (определяется по флагу HSIRDY)
	while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET) {}
	// сбрасываем калибровку
	// TODO: понять почему здесь 0х80 и переписать командами SET
	MODIFY_REG(RCC->CR, RCC_CR_HSITRIM, 0x80U);
	// очищаем конфигурационный регистр
	CLEAR_REG(RCC->CFGR);
	// ждём очистки флага SWS
	while (READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RESET) {}
	// отключаем PLL
	CLEAR_BIT(RCC->CR, RCC_CR_PLLON);
	// ждём пока контроллер не отпустит PLL (пока PLLRDY не станет равным 0)
	while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET) {}
	// выключаем HSE и его детектор тактового сигнала
	CLEAR_BIT(RCC->CR, RCC_CR_HSEON | RCC_CR_CSSON);
	// ожидание пока HSE не отключится
	while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET) {}
	// сброс бита разрешающего использование внешнего генератора
	CLEAR_BIT(RCC->CR, RCC_CR_HSEBYP);
	// сброс всех флагов прерываний от RCC
	SET_BIT(RCC->CSR, RCC_CSR_RMVF);
	// запрет всех прерываний от RCC
	CLEAR_REG(RCC->CIR);
}

/* Настройка частоты тактирования микроконтроллера на 72 МГц */
void clock_init()
{
	// Настройка системной частоты на 72 МГц
	// Включим внешнее тактирование HSE и дождёмся его включения
	SET_BIT(RCC->CR, RCC_CR_HSEON);
    while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET) {}

	// настройка памяти FLASH, включается буфер предварительной выборки,
	// сначала он отключается, затем включается максимальная задержка
	CLEAR_BIT(FLASH->ACR, FLASH_ACR_PRFTBE);
    SET_BIT(FLASH->ACR, FLASH_ACR_PRFTBE);

	// кажется в исходнике ошибка, FLASH_ACR_LATENCY_1 = 010 (то что нужно)
	// а FLASH_ACR_LATENCY_2, который везде указывается, на самом деле 100, такого режима нет 
    CLEAR_BIT(FLASH->ACR, FLASH_ACR_LATENCY);
	SET_BIT(FLASH->ACR, FLASH_ACR_LATENCY_1);

    // настраиваем делитель /1 AHB Prescaler
	CLEAR_BIT(RCC->CFGR, RCC_CFGR_HPRE);
	SET_BIT(RCC->CFGR, RCC_CFGR_HPRE_DIV1);

	// настройка делителя /1 APB2 Prescaler
	CLEAR_BIT(RCC->CFGR, RCC_CFGR_PPRE2);
	SET_BIT(RCC->CFGR, RCC_CFGR_PPRE2_DIV1);

	// настраиваем делитель /2 APB1 Prescaler
	CLEAR_BIT(RCC->CFGR, RCC_CFGR_PPRE1);
	SET_BIT(RCC->CFGR, RCC_CFGR_PPRE1_DIV2);

	// сбрасываем биты PLLSRC, PLLXTPRE, PLLMUL
	CLEAR_BIT(RCC->CFGR, RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL);
	// выбираем HSE осциллятор как вход для PLL
	SET_BIT(RCC->CFGR, RCC_CFGR_PLLSRC);
	// настраиваем PLLMul на коэффициент 9
	SET_BIT(RCC->CFGR, RCC_CFGR_PLLMULL9);
    // включаем PLL и ждём пока он не заблокируется
	SET_BIT(RCC->CR, RCC_CR_PLLON);
	while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET) {}
	// выбираем PLL в качестве источника системного тактирования
	CLEAR_BIT(RCC->CFGR, RCC_CFGR_SW); // сначала очищаем биты SW
	SET_BIT(RCC->CFGR, RCC_CFGR_SW_PLL);
	while(READ_BIT(RCC->CFGR, RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL) {}

}

/* Общая конфигурация системы: вызов функции настройки частоты тактирования 
на 72 МГц, включение тактирования AFIO, настройка портов для прошивания */
void system_config(void)
{ 
	clock_init();
	// включение тактирования AFIO
	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);
	tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_AFIOEN);
	// сбрасываем настройки SWD и JTAG
	CLEAR_BIT(AFIO->MAPR, AFIO_MAPR_SWJ_CFG);
	// и устанавливаем режим 010 - JTAG-DP Disabled and SW-DP Enabled
	SET_BIT(AFIO->MAPR, AFIO_MAPR_SWJ_CFG_JTAGDISABLE);

}

/* Настройка частоты системного счётчика для отсчёта тиков с периодом 1 мс */
void sys_tick_init()
{
	CLEAR_BIT(SysTick->LOAD, SysTick_LOAD_RELOAD_Msk);
	// задаётся значение RELOAD, чтобы бы период был равен 1 мс
	// T = (RELOAD + 1)/freq, RELOAD = T*freq - 1 = 0.001*72000000 - 1
	SET_BIT(SysTick->LOAD, SYSCLOCK/1000 - 1);
	NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL);
	// сброс счётчика
	CLEAR_BIT(SysTick->VAL, SysTick_VAL_CURRENT_Msk);
	// настройка управляющего регистра: установка системной частоты, разрешение
	// прерываний и включение счётчика
	SET_BIT(SysTick->CTRL, SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk | SysTick_CTRL_TICKINT_Msk);   
}

/** Установка задержки в заданное количество миллисекунд
*@param ms Число миллисекунд вызываемой задержки
 */
void delay_ms(uint32_t ms)
{
    CLEAR_BIT(SysTick->VAL, SysTick_VAL_CURRENT_Msk);
	SET_BIT(SysTick->VAL, SYSCLOCK/1000 - 1);
	SysTick_CNT = ms;
	while(SysTick_CNT) {}
}

/* Общая настройка портов ввода/вывода */
void gpio_setup()
{
	// включаем тактирование портов ввода/вывода А, В и С для отладки
	SET_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPAEN | RCC_APB2ENR_IOPBEN | RCC_APB2ENR_IOPCEN);
	// ждём
	tmpreg = READ_BIT(RCC->APB2ENR, RCC_APB2ENR_IOPAEN | RCC_APB2ENR_IOPBEN | RCC_APB2ENR_IOPCEN);
	// настраиваем порт С13 на выход push-pull с максимальной скоростью 50 МГц
	CLEAR_BIT(GPIOC->CRH, GPIO_CRH_CNF13);
	SET_BIT(GPIOC->CRH, GPIO_CRH_MODE13);
	// настраиваем порт A9 на выход push-pull с максимальной скоростью 50 МГц
	CLEAR_BIT(GPIOA->CRH, GPIO_CRH_CNF9);
	SET_BIT(GPIOA->CRH, GPIO_CRH_MODE9);
}


/* Инициализация DMA1 для USART2, функция должна быть вызвана внутри
функции USART2_Init перед настройкой управляющих регистров. На данный момент
решено использовать DMA только для передачи (TX), поскольку согласно концепции не
планируется отправлять от компьютера большой поток данных вниз на модуль. Достаточно будет
отправлять небольшие команды или установки каких-то переменных, адресов и т.д. */
static void dma1_init_for_usart2()
{
	// включаем тактирование контроллера DMA1
	RCC->AHBENR |= RCC_AHBENR_DMA1EN;
	tmpreg = (RCC->AHBENR & RCC_AHBENR_DMA1EN);

	NVIC_SetPriority(DMA1_Channel7_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
	NVIC_EnableIRQ(DMA1_Channel7_IRQn);

	// На всякий случай выключаем канал 7 
	DMA1_Channel7->CCR &= ~DMA_CCR_EN;

	/* 
	Настройка USART2_TX на передачу "наверх" к ПК. Пока что используется обычный фиксированный
	буфер для передачи*/
	// Настройка направления передачи - Memory to Peripheral
	DMA1_Channel7->CCR &= ~DMA_CCR_MEM2MEM;
	DMA1_Channel7->CCR |= DMA_CCR_DIR;
	// установка уровня приоритета - Low (пока непонятно какой нужен)
	DMA1_Channel7->CCR &= ~DMA_CCR_PL;
	// Режим передачи NORMAL - Circular mode disabled 
	DMA1_Channel7->CCR &= ~DMA_CCR_CIRC;
	//Set peripheral to NO increment mode DMA_CCR_PINC = 0
	DMA1_Channel7->CCR &= ~DMA_CCR_PINC;
	//Set memory increment mode
	DMA1_Channel7->CCR |= DMA_CCR_MINC;
	// Set peripheral data width - устанавливаем ширину данных с периферии
	// нужно 8 бит, поскольку USART получает 8 бит полезных данных
	DMA1_Channel7->CCR &= ~(DMA_CCR_PSIZE_1 | DMA_CCR_PSIZE_0);
	// Set memory data width - устанавливаем ширину данных в памяти
	// здесь тоже нужно 8 бит для согласованности
	DMA1_Channel7->CCR &= ~(DMA_CCR_MSIZE_1 | DMA_CCR_MSIZE_0);

	// Конфигурация адресов источника и приёмника для TX (write)
	DMA1_Channel7->CPAR = (uint32_t)&(USART2->DR); // адрес регистра приёмника

	// Enable Channel 7 Transfer complete interrupt and Transfer error interrupt
	DMA1_Channel7->CCR |= DMA_CCR_TCIE | DMA_CCR_TEIE;

	// Clear Channel 7 global interrupt flag, transfer complete flag and transfer error flag
    DMA1->IFCR = DMA_IFCR_CGIF7;
	DMA1->IFCR = DMA_IFCR_CTCIF7;
	DMA1->IFCR = DMA_IFCR_CTEIF7;


}


/* Инициализация USART2 - все настройки стандартные: асинхронный режим, фиксированная
   скорость 115200 бит/с, длина слова 8 бит, 1 стоп бит, контроля чётности нет,
   есть приём и передача
 */
void usart2_init()
{
	// инициализация USART2 
	RCC->APB1ENR |= RCC_APB1ENR_USART2EN; // включаем тактирование USART2
	tmpreg = RCC->APB1ENR & RCC_APB1ENR_USART2EN;
	/* Настройка портов - сначала нужно сбросить все настройки, 
	настройка порта PA2 (TX) на выход с максимальной скоростью,
	режим - alternate function push-pull.
	настройка порта PA3 (RX) на вход с режимом floating input */
	GPIOA->CRL &= ~(GPIO_CRL_CNF2 | GPIO_CRL_MODE2);
	GPIOA->CRL &= ~(GPIO_CRL_CNF3 | GPIO_CRL_MODE3);

	GPIOA->CRL |= GPIO_CRL_MODE2_1 | GPIO_CRL_MODE2_0; // 0b11 50MHz output
	GPIOA->CRL |= GPIO_CRL_CNF2_1; // PA2 (TX): output 50MHz - Alt-function Push-pull
	
	GPIOA->CRL |= GPIO_CRL_CNF3_0; // PA3 (RX): input floating

	dma1_init_for_usart2();

	/* настраиваем регистры USART2: асинхронный режим, включаем приём и передачу,
	устанавливаем скорость передачи - baudrate (пока что фиксированная
	скорость - 115200 бит/с), длина слова - 8 бит, 1 стоп бит */
	if ((USART2->CR1 & USART_CR1_UE) != USART_CR1_UE) // проверяем, вдруг уже включен USART
	{
		USART2->CR1 &= ~(USART_CR1_M | USART_CR1_PCE | USART_CR1_PS);
		USART2->CR1 |= USART_CR1_TE | USART_CR1_RE;
	}
	USART2->CR2 &= ~(USART_CR2_LINEN | USART_CR2_CLKEN);
	USART2->CR3 &= ~(USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL);
	USART2->BRR = 0x138; // рассчитывалось по даташиту, равно 19.53
	
	/* Включаем прерывания RXNE, которые генерируются если ORE=1 или RXNE=1 
	в регистре статуса USART_SR, т.е соответственно при переполнении (ORE) и когда
	принятые данные готовы к чтению (RXNE) */
	USART2->CR1 |= USART_CR1_RXNEIE;

	//Enable DMA Mode for transmission (DMAT) only
	USART2->CR3 |= USART_CR3_DMAT;
	
	// На всякий случай очищаем регистр передачи данных USART2
    USART2->DR = 0x00;
	USART2->SR |= USART_SR_TC;

	// разрешим глобальные прерывания USART2 для приёма данных по линии RX
	NVIC_SetPriority(USART2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 5, 1));
    NVIC_EnableIRQ(USART2_IRQn);

	// Включаем USART2
	USART2->CR1 |= USART_CR1_UE; // enable USART2

}

/* Details here: https://github.com/MaJerle/stm32-usart-uart-dma-rx-tx
 */
inline uint8_t usart_start_tx_dma_transfer()
{
	uint32_t old_primask;
	uint8_t start_flag = 0;
	
	old_primask = __get_PRIMASK();
    __disable_irq();

	// проверяем, что передача не активна в настоящий момент
	if (usart_dma_tx_len == 0)
	{
		// проверяем, есть ли что отправлять
		usart_dma_tx_len = lwrb_get_linear_block_read_length(&usart_dma_tx_buff);
		if (usart_dma_tx_len > 0)
		{	
			// создаём указатель на первый элемент в линейном блоке буфера на передачу
			void* ptr = lwrb_get_linear_block_read_address(&usart_dma_tx_buff);
			// Выключаем 7 канал DMA
			DMA1_Channel7->CCR &= ~DMA_CCR_EN;
			DMA1->IFCR = DMA_IFCR_CTCIF7;
			DMA1->IFCR = DMA_IFCR_CGIF7;
	        DMA1->IFCR = DMA_IFCR_CTCIF7;
	        DMA1->IFCR = DMA_IFCR_CTEIF7;
			// Начинаем DMA передачу
			// обнуляем число байт, которое следует отправить и пишем новое число
			DMA1_Channel7->CNDTR &= ~DMA_CNDTR_NDT;
			DMA1_Channel7->CNDTR = usart_dma_tx_len;
			// устанавливаем адрес памяти для передачи
			DMA1_Channel7->CMAR = (uint32_t)(ptr); // !тут static_cast не работает!
			DMA1_Channel7->CCR |= DMA_CCR_EN;
			start_flag = 1; 
		}
	}
	__set_PRIMASK(old_primask);
	return start_flag;
}

void usart_send_string(const char* str)
{
	// Записываем новые данные в буфер, только если предыдущая передача по USART уже закончилась
	if ((USART2->SR & USART_SR_TC) == USART_SR_TC)
	{
		// USART2->SR &= ~USART_SR_TC;
		lwrb_write(&usart_dma_tx_buff, str, strlen(str));
		usart_start_tx_dma_transfer();
	}
}

void usart_echo()
{
	// Начинаем передачу, только если предыдущая передача по USART уже закончилась
	if ((USART2->SR & USART_SR_TC) == USART_SR_TC)
	{
		// USART2->SR &= ~USART_SR_TC;
		usart_start_tx_dma_transfer();
	}
}



void serial_write(uint16_t size_of_data)
{
	/* Только после того как я добавил проверку этого условия передача
	по USART стала работать. Однако странно, что пример с narod stream
	не заработал (с применением флага) для точно такого же контроллера... */

	if ((USART2->SR & USART_SR_TC) == USART_SR_TC)
	{
		DMA1_Channel7->CCR &= ~DMA_CCR_EN;
	    DMA1_Channel7->CNDTR &= ~DMA_CNDTR_NDT;
	    DMA1_Channel7->CNDTR = size_of_data;
        DMA1_Channel7->CCR |= DMA_CCR_EN;
	
	}
}


void echo_usart()
{
}


int main() {

	system_config();
	sys_tick_init();
	gpio_setup();

    GREEN_LED_OFF;
	TESTPIN_OFF;

	usart2_init();
	lwrb_init(&usart_dma_tx_buff, usart_dma_tx_buff_data, sizeof(usart_dma_tx_buff_data));
	lwrb_init(&usart_rx_ringbuf, usart_rx_ringbuf_data, sizeof(usart_rx_ringbuf_data));

	usart_send_string("Module successfully initialized\n");

	while(1) 
	{
		// usart_send_string("Cosmic Space Commando Base\n");
		usart_echo();
		// delay_ms(100);
		// for (int j = 0; j < 100; j++)
		// {
		// 	snprintf(usart_tx_dma_buffer, 32, "%i", j);
		// 	strcat(usart_tx_dma_buffer, "\n");
		// 	serial_write(strlen(usart_tx_dma_buffer));
		//     delay_ms(50);
		// }
	}

	return 0;
}

/* Нужно добавлять для обработчиков прерываний (пока непонятно для всех
или для только SysTick) обёртку, которая позволяет воспринимать 
участок кода как код языка С (НЕ С++). Без этого функции обработчиков
прерываний не хотят работать  */
extern "C" 
{
    void SysTick_Handler(void) 
    {
    	// SET_BIT(GPIOC->BSRR, GPIO_BSRR_BR13);
    	if(SysTick_CNT > 0)  SysTick_CNT--;
    }
}

// обработчик прерывания от памяти к периферии (USART2-TX)
extern "C" 
{
	void DMA1_Channel7_IRQHandler(void)
	{
		
		if ((DMA1->ISR & DMA_ISR_TCIF7) == DMA_ISR_TCIF7) // сработало прерывание по окончанию передачи
		{
			GREEN_LED_ON;
			DMA1->IFCR = DMA_IFCR_CTCIF7;
			lwrb_skip(&usart_dma_tx_buff, usart_dma_tx_len);
			usart_dma_tx_len = 0;
			usart_start_tx_dma_transfer();
			GREEN_LED_OFF;
		}
		else if ((DMA1->ISR & DMA_ISR_TEIF7) == DMA_ISR_TEIF7)
		{
			// выключаем оба канала DMA
			DMA1_Channel6->CCR &= ~DMA_CCR_EN;
			DMA1_Channel7->CCR &= ~DMA_CCR_EN;
		}
	}
}



extern "C"
{
	/* Обработка прерывания по переносу данных из сдвигового регистра в USART_DR при приёме данных по RX */
	void USART2_IRQHandler(void) 
	{
		// произошло прерывание по получению данных: RXNE = 1
		if ((USART2->SR & USART_SR_RXNE) == USART_SR_RXNE)
		{
			TESTPIN_ON;
			uint8_t temp_byte[1];
			temp_byte[0] = static_cast<uint8_t>((USART2->DR & 0xFF));
			// lwrb_write(&usart_rx_ringbuf, &temp_byte, 1);
			lwrb_write(&usart_dma_tx_buff, temp_byte, 1); // для самотестировония
			// ring_buffer_queue(&usart_rx_buffer, temp_byte);
			TESTPIN_OFF;
		}

		// произошла ошибка по переполнению ORE = 1
		if ((USART2->SR & USART_SR_ORE) == USART_SR_ORE)
		{
			// просто очищаем этот флаг как указано в даташите
			(void) USART2->SR; // читаем регистр SR
			(void) USART2->DR; // и регистр DR
		}

	}
}